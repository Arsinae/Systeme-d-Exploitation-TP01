import { Process, Instruction } from '../process';

class ProcessSchedule {
  public id: number;
  public arrivedTime: number;
  public priority: number;
  public duration: number;
  public instructions: Array<number>;

  constructor(id, arrivedTime, priority, instructions: Array<Instruction>) {
    this.id = id;
    this.arrivedTime = arrivedTime;
    this.priority = priority;
    this.duration = 0;
    this.instructions = [];
    for (const instruction of instructions) {
      this.instructions.push(instruction.duration);
      this.duration += instruction.duration;
    }
  }
}

export class Schedule {

  public processes: Array<ProcessSchedule> = [];
  public processRepresentation: Array<{current: {processId: number, instructionId: number}, processState: Array<string>}> = [];

  constructor() {
  }

  setProcess(processes) {
    this.processes = [];
    for (const process of processes) {
      this.processes.push(new ProcessSchedule(process.id, process.arrivedTime, process.priority, process.instructions));
    }
  }

  initializeProcessRepresentation() {
    this.processRepresentation = [];
    this.processRepresentation.push({
      current: {processId: 0, instructionId: 0},
      processState: Array.from({length: this.processes.length}).map(x => 'out')
    });
  }

  getProcessDuration(process) {
    let count = 0;
    for (const instruction of process.instructions) {
      count += instruction;
    }
    return count;
  }

  isCompleted(processState) {
    for (const process of processState) {
      if (process !== 'ended') {
        return false;
      }
    }
    return true;
  }

  changeComing(index, processRepresentation) {
    for (let i = 0; i < this.processes.length; i++) {
      if (this.processes[i].arrivedTime === index) {
        processRepresentation.processState[i] = 'waiting';
      }
    }
  }

  actionOnEndProcess(current, time) {
  }

  setRunning(current, timeIndex) {
    let waiting = {index: -1, arrived: -1};
    for (let i = 0; i < this.processes.length; i++) {
      if (current.processState[i] === 'waiting' &&
      (waiting.index === -1 || this.processes[i].arrivedTime < waiting.arrived)) {
        waiting = {index: i, arrived: this.processes[i].arrivedTime};
      }
    }
    if (waiting.index !== -1) {
      return {processIndex: waiting.index, end: timeIndex + this.processes[waiting.index].duration};
    } else {
      return {processIndex: -1, end: 0};
    }
  }

  getInstructionId(instructions, index, end) {
    let current = end - instructions[instructions.length - 1];
    let i = instructions.length - 1;
    for (; i >= 0 && current > index; i--) {
      current -= instructions[i - 1];
    }
    return i;
  }

  manageProcess(processes) {
    this.setProcess(processes);
    this.initializeProcessRepresentation();
    let running = {processIndex: -1, end: 0};
    for (let i = 1; !this.isCompleted(this.processRepresentation[this.processRepresentation.length - 1].processState); i++) {
      const current = {
        current: {processId: 0, instructionId: 0},
        processState: this.processRepresentation[this.processRepresentation.length - 1].processState.slice()
      };
      this.changeComing(i, current);
      if (i === running.end || running.end === 0) {
        current.processState[running.processIndex] = 'ended';
        if (i === running.end) {
          this.actionOnEndProcess(current, i);
        }
        running = this.setRunning(current, i);
      }
      if (running.processIndex !== -1) {
        current.current.processId = this.processes[running.processIndex].id;
        current.current.instructionId = this.getInstructionId(this.processes[running.processIndex].instructions, i, running.end);
        current.processState[running.processIndex] = 'running';
      }
      this.processRepresentation.push(current);
    }
    return this.processRepresentation;
  }
}
