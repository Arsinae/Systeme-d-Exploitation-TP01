import { Process } from '../process';

export class Schedule {

  public processes: Array<Process> = [];
  public processRepresentation: Array<{current: {processId: number, instructionId: number}, processState: Array<string>}> = [];

  constructor() {
  }

  setProcess(processes) {
    this.processes = processes.slice(0);
  }

  initializeProcessRepresentation() {
    this.processRepresentation = [];
    this.processRepresentation.push({
      current: {processId: 0, instructionId: 0},
      processState: Array.from({length: this.processes.length}).map(x => 'out')
    });
  }

  getProcessDuration(process) {
    let count = 0;
    for (const instruction of process.instructions) {
      count += instruction.duration;
    }
    return count;
  }

  isCompleted(processState) {
    for (const process of processState) {
      if (process !== 'ended') {
        return false;
      }
    }
    return true;
  }

  changeComing(index, processRepresentation) {
    for (let i = 0; i < this.processes.length; i++) {
      if (this.processes[i].arrivedTime === index) {
        processRepresentation.processState[i] = 'waiting';
      }
    }
  }

  setRunning(current, timeIndex) {
    let waiting = {index: -1, arrived: -1};
    for (let i = 0; i < this.processes.length; i++) {
      if (current.processState[i] === 'waiting' &&
      (waiting.index === -1 || this.processes[i].arrivedTime < waiting.arrived)) {
        waiting = {index: i, arrived: this.processes[i].arrivedTime};
      }
    }
    if (waiting.index !== -1) {
      return {processIndex: waiting.index, end: timeIndex + this.getProcessDuration(this.processes[waiting.index])};
    } else {
      return {processIndex: -1, end: 0};
    }
  }

  getInstructionId(instructions, index, end) {
    let current = end - instructions[instructions.length - 1].duration;
    let i = instructions.length - 1;
    for (; i >= 0 && current > index; i--) {
      current -= instructions[i - 1].duration;
    }
    return i;
  }

  manageProcess(processes) {
    this.setProcess(processes);
    this.initializeProcessRepresentation();
    let running = {processIndex: -1, end: 0};
    for (let i = 1; !this.isCompleted(this.processRepresentation[this.processRepresentation.length - 1].processState); i++) {
      const current = {
        current: {processId: 0, instructionId: 0},
        processState: this.processRepresentation[this.processRepresentation.length - 1].processState.slice()
      };
      this.changeComing(i, current);
      if (i === running.end || running.end === 0) {
        current.processState[running.processIndex] = 'ended';
        running = this.setRunning(current, i);
      }
      if (running.processIndex !== -1) {
        current.current.processId = this.processes[running.processIndex].id;
        current.current.instructionId = this.getInstructionId(this.processes[running.processIndex].instructions, i, running.end);
        current.processState[running.processIndex] = 'running';
      }
      this.processRepresentation.push(current);
    }
    return this.processRepresentation;
  }
}
