import { Schedule } from './schedule';

export class PCASchedule extends Schedule {

  setRunning(current, timeIndex) {
    let waiting = {index: -1, duration: -1};
    for (let i = 0; i < this.processes.length; i++) {
      if (current.processState[i] === 'waiting' &&
      (waiting.index === -1 || this.processes[i].duration < waiting.duration)) {
        waiting = {index: i, duration: this.processes[i].duration};
      }
    }
    if (waiting.index !== -1) {
      return {processIndex: waiting.index, end: timeIndex + waiting.duration};
    } else {
      return {processIndex: -1, end: 0};
    }
  }

  endOfInstruction(processIndex, time, end) {
    let tmpEnd = end;
    for (let i = this.processes[processIndex].instructions.length - 1; i >= 0; i--) {
      tmpEnd -= this.processes[processIndex].instructions[i];
      if (tmpEnd === time) {
        return true;
      }
    }
    return false;
  }

  searchShortestProcess(current, time, processState) {
    let running = {processIndex: current.processIndex, end: current.end};
    for (let i = 0; i < processState.length; i++) {
      if (processState[i] === 'waiting' && this.processes[i].duration + time < running.end) {
        running = {processIndex: i, end: this.processes[i].duration + time};
      }
    }
    if (running.processIndex !== current.processIndex) {
      processState[current.processIndex] = 'waiting';
      this.processes[current.processIndex].duration = current.end - time;
    }
    return running;
  }

  manageProcess(processes) {
    this.setProcess(processes);
    this.initializeProcessRepresentation();
    let running = {processIndex: -1, end: 0};
    for (let i = 1; !this.isCompleted(this.processRepresentation[this.processRepresentation.length - 1].processState); i++) {
      const current = {
        current: {processId: 0, instructionId: 0},
        processState: this.processRepresentation[this.processRepresentation.length - 1].processState.slice()
      };
      this.changeComing(i, current);
      if (i === running.end || running.end === 0) {
        current.processState[running.processIndex] = 'ended';
        running = this.setRunning(current, i);
      } else if (this.endOfInstruction(running.processIndex, i, running.end)) {
        running = this.searchShortestProcess(running, i, current.processState);
      }
      if (running.processIndex !== -1) {
        current.current.processId = this.processes[running.processIndex].id;
        current.current.instructionId = this.getInstructionId(this.processes[running.processIndex].instructions, i, running.end);
        current.processState[running.processIndex] = 'running';
      }
      this.processRepresentation.push(current);
    }
    return this.processRepresentation;
  }
}
